{"data":{"site":{"siteMetadata":{"title":"kkdev163 ' Blog","author":"kk"}},"markdownRemark":{"id":"19f99f52-eb9c-59ee-b3cf-ac9232de3cbc","excerpt":"ES 的存储类型 ES 的存储类型大致分为两类 结构化数据 类型为 keyword、date、long、boolean 等 文本数据 类型为 text 存储索引建立规则： ES在存储结构化数据类型时，会将数据作为一个整体建立倒排索引。 ES…","html":"<h3>ES 的存储类型</h3>\n<p>ES 的存储类型大致分为两类</p>\n<ul>\n<li>结构化数据 类型为 keyword、date、long、boolean 等</li>\n<li>文本数据 类型为 text</li>\n</ul>\n<p>存储索引建立规则：</p>\n<ul>\n<li>ES在存储结构化数据类型时，会将数据作为一个整体建立倒排索引。</li>\n<li>ES在存储文本数据类型时，会将文本先进行分词处理，然后按各个单独的词项建立倒排索引。</li>\n</ul>\n<p>举例来说：</p>\n<p>假设索引字段的定义如下：</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>字段类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>appName</td>\n<td>keyword</td>\n</tr>\n<tr>\n<td>description</td>\n<td>text</td>\n</tr>\n</tbody>\n</table>\n<p>当插入以下两条数据时</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>appName</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>App Store</td>\n<td>App Store is Awesome</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Apple Store</td>\n<td>Store Sell Apple Pie</td>\n</tr>\n</tbody>\n</table>\n<p>ES 会为 appName 字段建立如下的倒排索引：</p>\n<table>\n<thead>\n<tr>\n<th>索引</th>\n<th>文档id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>App Store</td>\n<td>1</td>\n</tr>\n<tr>\n<td>Apple Store</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<p>ES 会为 description 字段建立如下的倒排索引：</p>\n<table>\n<thead>\n<tr>\n<th>索引</th>\n<th>文档id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>app</td>\n<td>1</td>\n</tr>\n<tr>\n<td>store</td>\n<td>1, 2</td>\n</tr>\n<tr>\n<td>awesome</td>\n<td>1</td>\n</tr>\n<tr>\n<td>sell</td>\n<td>2</td>\n</tr>\n<tr>\n<td>apple</td>\n<td>2</td>\n</tr>\n<tr>\n<td>pie</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<p>注：通用分词器会将词项转为小写</p>\n<h3>ES 的搜索</h3>\n<p>ES 的搜索分为两大类</p>\n<ul>\n<li>基于词项的搜索(Term 搜索)</li>\n<li>基于全文的搜索</li>\n</ul>\n<h4>基于词项的搜索</h4>\n<p>在进行基于词项的搜索，搜索词 与 文档字段需完全匹配。</p>\n<p>ES 提供了五种基于词项的搜索方法</p>\n<ul>\n<li>term</li>\n<li>range</li>\n<li>exists</li>\n<li>prefix</li>\n<li>wildcard</li>\n</ul>\n<h5>DEMO 举例</h5>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>appName</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>App Store</td>\n<td>App Store is Awesome</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Apple Store</td>\n<td>Store Sell Apple Pie</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n    &quot;query&quot;: {\n        &quot;term&quot;: {\n            &quot;appName&quot;: &quot;App Store&quot; // 可搜索到\n            // &quot;appName&quot;: &quot;App&quot;  // 无法搜索到\n        }\n    }\n}</code></pre></div>\n<h4>基于全文的搜索</h4>\n<p>ES 主要提供了两种基于全文的搜索方法</p>\n<ul>\n<li>match</li>\n<li>match_phrase</li>\n</ul>\n<p>在进行 match 搜索时，ES 会先将查询字符串进行分词，然后将每个词项与倒排索引进行匹配，任意一个词项匹配到，即搜索成功。</p>\n<p>在进行 match_phrase 搜索时，ES 将查询字符串看作一个整体，只有文档中包含该短语字符串时，才搜索成功。</p>\n<h5>DEMO</h5>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>appName</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>App Store</td>\n<td>App Store is Awesome</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Apple Store</td>\n<td>Store Sell Apple Pie</td>\n</tr>\n</tbody>\n</table>\n<p>ES 会为 description 字段建立如下的倒排索引：</p>\n<table>\n<thead>\n<tr>\n<th>索引</th>\n<th>文档id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>app</td>\n<td>1</td>\n</tr>\n<tr>\n<td>store</td>\n<td>1, 2</td>\n</tr>\n<tr>\n<td>awesome</td>\n<td>1</td>\n</tr>\n<tr>\n<td>sell</td>\n<td>2</td>\n</tr>\n<tr>\n<td>apple</td>\n<td>2</td>\n</tr>\n<tr>\n<td>pie</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<h6>match 举例</h6>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n    &quot;query&quot;: {\n        &quot;match&quot;: {\n            &quot;description&quot;: &quot;App&quot; // 可以搜到文档1\n          //&quot;description&quot;: &quot;App Store&quot;  // 可以搜索到文档1，2 (会先将App Store分词, 通过 Store 搜到了文档2)\n          //&quot;description&quot;: &quot;App Awesome&quot;  // 可以搜索到文档1 (还是进行了分词)\n        }\n    }\n}</code></pre></div>\n<h5>match_phrase 举例</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n    &quot;query&quot;: {\n        &quot;match_phrase&quot;: {\n            &quot;description&quot;: &quot;App&quot; // 搜到文档1\n          //&quot;description&quot;: &quot;App Store&quot;  // 搜索文档1 (App Store是一个整体)\n          //&quot;description&quot;: &quot;App Awesome&quot;  // 无法查到 (App Awesome是一个整体)\n        }\n    }\n}</code></pre></div>\n<h3>复合查询</h3>\n<p>以上为单条件查询，但通常业务上需要基于多个条件进行查询，ES 提供了 bool 复合查询，该查询可以包含4个查询字句，分别是</p>\n<ul>\n<li>must 必须全部符合该条件。贡献算分(算分可以简单理解为搜索的匹配度)</li>\n<li>should 符合条件之一即可。 贡献算分</li>\n<li>must_not 必须不符合该条件。 不贡献算分，有缓存优化</li>\n<li>filter 必须符合该条件。不贡献算分，有缓存优化</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n    &quot;query&quot;: {\n        &quot;bool&quot;: {\n            &quot;must&quot;: [{  // 复合查询子句\n                &quot;term&quot;: {  // 基于词项搜索\n                    &quot;appName&quot;: &quot;App Store&quot;\n                }\n            }, {\n                &quot;range&quot;: { // 基于词项的范围搜索\n                    &quot;time&quot;: {\n                        &quot;lgt&quot;: &quot;2019-01-01&quot;\n                    }\n                }\n            }, {\n                &quot;wildcard&quot;: { // 基于词项的通配符搜索\n                    &quot;appName&quot;: &quot;* Store&quot; \n                }\n            }, {\n                &quot;match&quot;: { // 基于全文的 match 搜索\n                    &quot;description&quot;: &quot;App Store&quot;\n                }\n            }, {\n                &quot;match_phrase&quot;: { // 基于全文的 match_phrase 搜索\n                    &quot;description&quot;: &quot;App Store&quot;\n                }\n            }]\n            &quot;should&quot;: [{  // 复合查询子句\n                ...\n            }],\n            &quot;must_not&quot;: [{ // 复合查询子句\n                ...\n            }],\n            &quot;filter&quot;: [{ // 复合查询子句\n                ...\n            }]\n        }\n    }\n}</code></pre></div>\n<p>一般情况下，在不需要算分的场景下，建议使用 filter 和 must_not, 因为不需要进行算分，ES 会有缓存优化。</p>\n<p>另外每一个查询字句，可以继续嵌套 bool 查询。示意如下:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n    &quot;query&quot;: {\n        &quot;bool&quot;: {\n            &quot;must&quot;: [{  \n                &quot;bool&quot;: {  \n                    &quot;must&quot;:{...},\n                    &quot;should&quot;: {...},\n                }\n            }]\n        }\n    }\n}</code></pre></div>\n<p>由于复合查询的 body 构造较为繁复，我们可以使用 <a href=\"https://github.com/danpaz/bodybuilder\">bodybuilder</a> 来简化这一过程。</p>\n<p>示意如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var body = bodybuilder().query(&#39;match&#39;, &#39;message&#39;, &#39;this is a test&#39;).build()\n// body == {\n//   query: {\n//     match: {\n//       message: &#39;this is a test&#39;\n//     }\n//   }\n// }</code></pre></div>\n<p>详细<a href=\"https://bodybuilder.js.org/docs/\">API文档</a></p>","frontmatter":{"title":"ES(ElasticSearch) 搜索基本概念简介","date":"April 02, 2020","description":"本篇文章介绍了 ES(ElasticSearch) 搜索相关的基本概念"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/elastic-search/","previous":{"fields":{"slug":"/lighthouse/"},"frontmatter":{"title":"Lighthous 测试内幕"}},"next":null}}